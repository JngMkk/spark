# 10장 GraphX

```
페이스북 예시.

유저들은 페이스북 친구가 있고 페이스북 친구는 또 다른 친구가 있으며, 그 친구는 또 다른 친구가 있음.
페이스북에는 새로운 친구를 사귈 수 있거나 친구 목록에서 친구를 삭제할 수 있는 설정이 있음.
또한 페이스북에는 누가 무엇을 보는지, 누가 누구와 얘기하고 있는지 세밀하게 제어할 수 있는 권한이 있음.

10억 명의 페이스북 사용자가 있다고 생각하면 모든 사용자의 친구와 친구의 친구 목록은 상당히 크고 복잡해짐.
서로 다른 모든 관계를 이해하고 관리하기란 어려움.

따라서 누군가가 어떤 사람 X와 다른 사람 Y가 관련이 있는지 알고 싶다면
단순히 모든 친구와 모든 친구의 친구를 보고 시작해서 사람 Y를 찾으려 할 것임.
사람 Y가 친구의 친구이면 사람 Y는 간접적으로 연결됨.

다음과 같은 질문에 답할 수 있게 사람들과 친구들에 대해 테이터 저장소와 검색 기능을 구축해야 함.
	1) X는 Y의 친구인가?
	2) X와 Y가 직접적으로 연결돼 있거나 두 단계로 연결돼 있는가?
	3) X는 몇 명의 친구가 있는가?
	
모든 사람이 친구 배열을 갖고 있듯이 배열과 같은 간단한 데이터 구조로 시작할 수 있을 것임.
질문 3에 대답하기 위해 배열의 길이를 쉽게 얻을 수 있고, 배열을 검색해서 질문 1에 대답할 수 있음.
질문 2는 더 많은 작업을 필요로 함. X의 친구 배열을 얻고 배열에 저장된 각 친구에게서 친구 배열을 검색함.
```

```scala
case class Person(name: String) {
	val friends = scala.collection.mutable.ArrayBuffer[Person]()
    
    def numOfFriends() = friends.length
    
    def isFriend(other: Person) = friends.find(_.name == other.name)
    
    def isConnectedWithin2Steps(other: Person) = {
		for {f <- friends} yield {
            f.name == other.name || f.isFriend(other).isDefined
        }
    }.contains(true)
}
```



```
관계망 표현.

버텍스 집합을 V로, 에지 집합을 E로 그래프 G = (V, E)

수학적 그래프는 수학적 기법을 사용해 그래프를 탐색하고 쿼리하는 다양한 방법론을 제공함.
그래프 기술이 필요한 수학을 수행하기 위한 프로그래밍 방식을 개발하는 방법을 컴퓨터 과학에 적용한다면
공식적인 접근 방식은 확장 가능하고 효율적인 수준으로 수학적 규칙을 구현하는 알고리즘을 개발하는 것임.

이미 Person 케이스 클래스를 사용해 간단한 그래프와 유사한 프로그램을 구현하려고 시도했지만,
이것은 가장 단순한 사용 사례일 뿐임. 다음 질문에 답할 수 있는 것처럼 복잡한 확장 문제가 있음.

	- X에서 Y까지 가려면 가장 좋은 방법은 무엇인가?
		예로 식료품 가게에 갈 수 있는 가장 좋은 방법을 알려주는 자동차 네비게이션을 들 수 있음.
	  
	- 그래프를 나눌 수 있는 중요한 에지를 알 수 있는가?
		예로 국가에서 여러 도시의 인터넷 서비스 등을 연결하는 중요한 링크를 결정하는 것을 들 수 있음.
		중요한 에지는 연결을 끊을 수 있고 잘 연결된 도시의 두 개의 하위 그래프를 생성하지만,
		두 하위 그래프 간에는 통신이 없을 것임.

이런 질문에 답하려면 최소 스패닝 트리, 최단 경로, 페이지 순위, 교차 최소 제곱,
최대 컷 최소 흐름 알고리즘 등과 같은 여러 알고리즘을 생각할 수 있고, 다양한 사용 사례에 적용할 수 있음.

다른 예로는 버텍스와 에지의 그래프를 명확하게 볼 수 있는 링크드인 프로필과 커넥션,
트위터 팔로워, 구글 페이지 순위, 항공사 스케줄링, 자동차의 GPS 등이 있음.
그래프 알고리즘을 사용하면 앞서 페이스북, 링크드인, 구글 예에서 볼 수 있는 그래프를 통해
다양한 비즈니스 사용 사례를 산출하는 다양한 알고리즘으로 분석할 수 있음.
```



## 1. GraphX

```
많은 실제 사용 사례를 버텍스 집합과 버텍스를 연결하는 에지 집합의 그래프로 모델링할 수 있음.
해야할 일은 하나의 장비나 몇 대의 장비를 합친 것보다 훨씬 복잡한 아키텍처를 고려해
데이터양과 데이터 엘리먼트 간의 복잡한 상호 연결을 처리할 수 있는 복잡한 그래프 알고리즘을 구현하는 것임.

GrpahX는 RDD 개념 위에 그래프 추상화를 제공해 스파크 RDD를 확장함.
GraphX의 그래프는 객체 간의 관계를 설명하는 객체와
에지나 링크를 표현하기 위해 객체를 표현하는 버텍스나 노드의 개념을 사용해 생성됨.
GraphX는 그래프 처리 패러다임에 적합한 많은 사용 사례를 실현하는 수단을 제공함.

GraphX의 기초적인 데이터 구조는 그래프로, 버텍스 및 에지와 관련된 임의의 객체를 가진 그래프를 추상적으로 나타냄.
그래프는 기본 구조뿐 아니라 버텍스 및 에지와 관련된 데이터에 접근하고 조작하기 위한 기본 연산을 제공함.
스파크 RDD와 마찬가지로 그래프는 함수형 데이터 구조로서 변환 연산을 실행하면 새로운 그래프를 리턴함.
Graph 객체의 불변 성격 때문에 동기화 문제가 발생할 위험 없이 대규모 병렬 계산을 수행할 수 있음.
객체의 동시 업데이트나 변경은 많은 프로그램에서 수행되는 복잡한 다중 스레드 프로그래밍의 주요 이유임.

그래프는 기본 데이터 구조를 정의하며, 추가 편의 작업과 그래프 알고리즘을 포함하는 헬퍼 클래스인 GraphOps가 있음.

그래프는 그래프를 구성하는 두 부분의 데이터 타입을 지정하는 2개의 속성, 버텍스와 에지를 가진 클래스 템플릿으로 정의됨.

class Graph[VD: ClassTag, ED: ClassTag]

버텍스 집합은 VertexRDD로 알려진 특수 데이터 구조 안에 있음.
마찬가지로 에지 집합은 EdgeRDD라는 특수 데이터 구조 안에 있음.
버텍스와 에자가 함게 그래프를 형성하고 두 개의 데이터 구조를 사용해 모든 후속 연산을 수행할 수 있음.
```

###### 그래프 클래스 선언

```scala
class Graph[VD, ED] {
    // 버텍스와 버텍스와 관련된 속성을 포함한 RDD
    val vertices: VertexRDD[VD]
    
    // 에지 및 에지와 관련된 속성을 포함한 RDD
    // RDD 항목에는 에지 데이터와 소스 id와 대상 id를 포함함
    val edges: EdgeRDD[ED]
    
    // 주변 버텍스와 관련된 버텍스 데이터를 함께하는 에지 트리플렛을 포함하는 RDD
    val triplets: RDD[EdgeTriplet[VD, ED]]
}
```

```
EdgeTriplet 객체는 Edge 객체가 가진 srcId, dstId, attr 필드 외에도
출발 정점의 속성 객체(srcAttr)와 도착 정점의 속성 객체(dstAttr)를 제공함.

mapTriplets 메서드를 사용해 각 간선의 현재 속성 객체와 해당 간선과 연결된 정점의 속성을 바탕으로
새로운 간선 속성 객체를 생성할 수 있음.
```

---



## 2. VertexRDD와 EdgeRDD

```
VertexRDD는 특수 데이터 구조의 버텍스나 노드 집합을 포함하고,
EdgeRDD는 특수 데이터 구조의 노드 및 버텍스 간의 에지나 링크 집합을 다시 포함함.
VertexRDD와 EdgeRDD는 모두 RDD를 기반으로 하고,
VertexRDD는 그래프의 모든 단일 노드를 처리하는 반면 EdgeRDD는 모든 노드 간의 모든 링크를 포함함.
```



### VertexRDD

```
버텍스와 관련 속성을 포함하는 RDD임. RDD의 각 엘리먼트는 그래프의 버텍스나 노드를 나타냄.
버텍스의 고유성을 유지하려면 각 버텍스에 고유한 ID를 할당해야 함.
이를 위해 GraphX는 VertexId로 알려진 매우 중요한 식별자를 정의함.
VertexId는 그래프 내의 버텍스를 고유하게 식별하는 64비트 버텍스 식별자로 정의됨.
고유성 이외의 순서나 제약 조건을 따를 필요가 없음.

VertexId의 선언은 다음과 같이 단순히 64비트 Long 번호에 대한 별칭임.
	type VertexId = Long

VertexRDD는 한 쌍의 VertexID와 RDD[(VertexID, VD)]로 나타내는 버텍스 속성의 RDD를 확장함.
또한 각 버텍스에 대해 하나의 항목만 있고, 빠르고 효율적인 조인을 위해 항목을 미리 색인할 수 있음.
동일한 인덱스를 가진 2개의 VertexRDD를 효율적으로 결합할 수 있음.

	class VertexRDD[VD]() extends RDD[(VertexId, VD)]

또한 VertexRDD는 그래프 연산과 관련된 중요한 함수를 제공하는 많은 함수를 구현함.
각 함수는 일반적으로 VertexRDD로 표현된 버텍스 입력을 허용함.
```



### EdgeRDD

```
EdgeRDD는 버텍스 사이의 에지 집합을 나타내며, Graph 클래스의 멤버임.
EdgeRDD는 VertexRDD와 마찬가지로 RDD에서 확장되며, Edge 속성과 Vertex 속성을 모두 사용함.

EdgeRDD[ED, VD]는 성능을 위해 각 파티션에 에지를 칼럼 포맷으로 저장해 RDD[Edge[ED]]를 확장함.
트리플렛 뷰를 제공하기 위해 각 에지에 관련된 버텍스 속성을 추가로 저장할 것임.

	class EdgeRDD[ED]() extends RDD[Edge[ED]]

또한 EdgeRDD는 그래프 연산과 관련된 중요한 기능을 제공하는 많은 함수를 구현함.
각 함수는 일반적으로 EdgeRDD가 나타내는 에지 입력을 제공받음.
각 에지는 소스 vertexId, 대상 vertexId, String, Integer, 모든 케이스 클래스와 같은 에지 속성으로 구성됨.
```

---



## 3. 그래프 연산자

### filter

```
filter 함수는 특정 버텍스 집합에서 주어진 조건자를 만족시키는 버텍스 집합으로 제한함.
filter 함수는 소스 RDD와의 효율적으로 조인하기 위해 인덱스를 유지하며,
새 메모리를 할당하는 대신 비트 마스크에 비트를 설정함.

	def filter(pred: Tuple2[VertexId, VD] => Boolean): VertexRDD[VD]
```



### mapValues

```
mapValues는 각 버텍스 속성을 매핑해 vertexID를 변경하지 않게 인덱스를 유지함.
vertexID를 변경하면 인덱스가 너무 많이 변경돼 후속 연산이 실패하고 버텍스에 더 이상 접근할 수 없게 됨.
따라서 vertexID를 변경하지 않는 것이 중요함.

	def mapValues[VD2: ClassTag](f: VD => VD2): VertexRDD[VD2]
	def mapValues[VD2: ClassTag](f: (VertexId, VD) => VD2): VertexRDD[VD2]
	
	// 구조를 유지하면서 값을 변경하는 에지 파티셔닝에 값을 매핑함.
	def mapValues[ED2: ClassTag](f: Edge[ED] => ED2): EdgeRDD[ED2]
```



### aggregateMessages

```
GraphX의 핵심 집계 연산임.
사용자 정의 sendMsg 함수를 그래프의 각 에지 트리플렛에 적용한 후 mergeMsg 함수를 사용해 대상 지점에서 메시지를 집계함.
많은 그래프 알고리즘에서 사용되며, 버텍스 간에 정보를 교환해야 할 때 사용됨.

그래프의 각 버텍스에서 임의의 함수를 실행하고 필요에 따라 인접 버텍스로 메시지를 전송할 수 있음.
그런 다음 각 버텍스에 도착한 메시지를 모두 집계하고 그 결과를 새로운 VertexRDD에 저장함.

	def aggregateMessages[Msg: ClassTag](
		sendMsg: EdgeContext[VD, ED, Msg] => Unit,
		mergeMsg: (Msg, Msg) => Msg,
		tripletFields: TripletFields = TripletFields.All
	): VertexRDD[Msg]
	
주요 함수는 sendMsg와 mergeMsg임. 두 함수는 에지의 소스 버텍스나 대상 버텍스로 보내지는 것을 결정함.
그다음 mergeMsg는 모든 에지에서 받은 메시지를 처리하고 계산 또는 집계를 수행함.
메서드의 선택 인수로 tripletFields 속성을 지정할 수 있음.

sendMsg 함수에는 그래프의 각 간선별로 전달된 EdgeContext 객체를 사용해 각 간선의 메시지 전송 여부를 검토하고,
필요하면 해당 간선에 연결된 인접 정점으로 메시지를 전송하는 로직을 구현함.
EdgeContext 객체에는 출발 정점 및 도착 정점의 ID, 정점 속성 객체, 간선 속성 객체가 전달됨.
EdgeContext는 또한 간선에 연결된 인접 정점에 메시지를 보낼 수 있는 두 가지 메서드를 제공(sendToSrc, sendToDst)
결국 sendMsg 함수는 주어진 EdgeContext를 사용해 어떤 메시지를 어느 정점에 보내야 할지 결정해야 함.

mergeMsg 함수에는 각 정점에 도착한 메시지들을 집계하는 로직을 구현함.
aggregateMessages 메서드의 마지막 인수인 tripletFields는 EdgeContext에 어떤 데이터 필드를 전달할지 지정함.
인수 값으로 TripletFields 클래스의 정적 필드(None, EdgeOnly, Src, Dst 및 All) 중 하나를 전달할 수 있음.
```



### triangleCount

```
버텍스의 두 이웃이 에지로 연결돼 있으면 삼각형이 생성됨. 그래프의 삼각형을 계산하는 triangleCount 함수가 있음.
```

---



## 4. Pregel API

```
프리겔은 구글이 개발한 대규모 그래프 처리 시스템.
GraphX에도 프리겔 API가 구현되어 aggregateMessages 메서드와 유사한 기능을 제공함.
하지만 르리겔의 성능이 더 강력한 관계로 GraphX 그래프 알고리즘 중 상당수가 프리겔을 사용함.

프리겔은 superstep이라는 일종의 반복 시퀀스를 실행해 메시지를 전달함.
각 superstep은 aggregateMessages 메서드와 유사한 과정, 즉 각 간선에서 sendMsg 함수를 호출하고
동일한 정점에 도착한 메시지를 mergeMsg 함수로 병합하는 과정을 수행함.
또 프리겔은 각 정점별로 사용자 정의 정점 프로그램(vprog)을 호출함.
vprog 함수는 정점으로 유입된 메시지를 받아 해당 정점에 할당할 새로운 값을 계산함.
VertexRDD를 반환하는 aggregateMessages와 달리 프리겔은 Graph를 반환함.
따라서 각 정점에 유입된 메시지를 mergeMsg로 병합한 후 병합된 메시지를 정점 속성 객체로 변환하는 함수가 필요함.

첫 번째 superstep은 모든 정점에서 실행되며, 이어지는 후속 superstep은 메시지를 받은 정점에서만 실행됨.
다시 말해 두 번째 superstep부터는 메시지를 받은 정점과 연결된 간선에서만 sendMsg 함수를 호출함.
알고리즘은 더 이상 새로운 메시지가 발생하지 않거나 최대 반복 횟수에 도달하면 superstep을 중지함.
스파크 GraphX의 프리겔 API는 Pregel 클래스로 사용함.

Pregel.apply 메서드 시그니처

def apply[VD: ClassTag, ED: ClassTag, A: ClassTag](
	graph: Graph[VD, ED],
	initialMsg: A,
	maxIterations: Int = Int.maxValue,
	activeDirection: EdgeDirection = EdgeDirection.Either
	)(
	vprog: (VertexId, VD, A) => VD,
    sendMsg: EdgeTriplet[VD, ED] => Iterator[(VertexId, A)],
    mergeMsg: (A, A) => A
): Graph[VD, ED]

	- graph: 연산을 실행할 입력 그래프.
	- initalMsg: 첫 번째 superstep에서 모든 정점에 보낼 초기 메시지.
	- maxIterations: superstep의 최대 실행 횟수.
	- activeDirection: sendMsg 함수를 호출할 간선의 조건을 지정.
						EdgeDirection.Out(간선의 출발 정점이 메시지를 받았을 때),
						EdgeDirection.In(간선의 도착 정점이 메시지를 받았을 때),
						EdgeDirection.Either(출발, 도착 정점 중 최소 한 정점이 메시지를 받았을 때),
						EdgeDirection.Both(출발, 도착 정점 모두 메시지를 받았을 때)
	- vprog: 각 정점별로 호출되는 정점 프로그램 함수를 전달함.
				이 함수에서는 정점으로 유입되는 메시지를 수신하고 정점 내용을 변경할 수 있음.
	- sendMsg: EdgeTriplet을 받고 (정점 ID, 메시지) 튜플의 Iterator를 반환하는 함수를 전달함.
				메시지는 튜플에 지정된 정점으로 전송됨.
	- mergeMsg: 동일한 정점에 도착한 메시지들을 병합하는 함수를 전달함.

그래프는 본질적으로 재귀 데이터 구조며,
버텍스의 속성은 버텍스의 이웃 속성에 따라 달라지고 해당 버텍스의 이웃 속성에 따라 달라짐.
결과적으로 많은 중요한 그래프 알고리즘은 고정 소수점 조건에 도달할 때까지 각 버텍스의 속성을 반복적으로 재계산함.
이러한 반복 알고리즘을 표현하기 위해 그래프-평행 추상화의 범위가 제안됨.
GraphX는 Pregel API의 변형을 보여줌.

GraphX의 Pregel 연산자는 하이레벨에서 그래프의 토폴로지에 제약을 받는 대량 동기 병렬 메시징 추상화임.
Pregel 연산자는 여러 단계로 수행됨.

처음 단계에서 버텍스는 이전 슈퍼 단계에서 버텍스의 인바운드 메시지 합계를 수신하고
버텍스 속성의 새 값을 계산한 후 다음 슈퍼 단계의 인접 버텍스에 메시지를 보냄.
(슈퍼 단계: 버텍스에서 로컬 계산, 통신, 베리어 동기화 과정을 포함하며, 한 번에 계산되는 과정을 의미함
따라서 버텍스의 계산 과정은 각각의 슈퍼 단계 단위로 이뤄짐.)
Pregel을 사용하면 메시지는 에지 트리플렛 함수로 병렬로 계산되며,
메시지를 계산할 때 소스 버텍스 속성과 대상 버텍스 속성에 모두 접근할 수 있음.
메시지를 수신하지 않은 버텍스는 슈퍼 스텝 내에서 건너 뜀.
Pregel 연산자는 반복을 종료하고 남아있는 메시지가 없다면 마지막 그래프를 리턴함.

Pregel API를 사용해 기본적으로 제공하는 알고리즘
	- 연결 컴포넌트
	- 최단 경로
	- 여행하는 세일즈맨
	- 페이지랭크

	def pregel[A](
		// 모든 버텍스에 보낼 초기 메시지
		initialMsg: A,
		// 반복 개수
		maxIter: Int = Int.MaxValue,
		activeDirection: EdgeDirection = EdgeDirection.Either
		)
		// 입력 또는 출력 에지
		(vprog: (VertexId, VD, A) => VD,
		// 메시지 함수를 보냄
		sendMsg: EdgeTriplet[VD, ED] => Iterator[(VertexId, A)],
		// 전략 병합
		mergeMsg: (A, A) => A
		): Graph[VD, ED]
```



### Connected Components

```
그래프의 연결요소는 모든 정점에서 다른 모든 정점으로 도달할 수 있도록 연결된 서브그래프를 의미함.
연결요소는 비방향성 그래프의 서브그래프임.
GraphX에서는 방향성 그래프만 만들 수 있으므로 GraphX의 연결요소 알고리즘은 간선 방향성을 무시함.
그래프의 연결요소가 오직 한 개만 있으며, 그래프의 모든 정점이 다른 모든 정점으로 도달할 수 있을 때 이를 연결그래프라 함.

실제 사례에서는 연결요소를 분석하는 작업이 상당히 중요함.
예를 들어 다른 그래프 알고리즘을 실행하기에 앞서 대상 그래프가 연결그래프인지 반드시 확인하는 편이 좋음.
연결그래프가 아닐 때 알고리즘 결과에도 악영향을 미쳐 결론을 왜곡할 수 있음.

GraphX에서는 Graph의 connectedComponents 메서드를 호출해 연결요소를 찾을 수 있음
(메서드는 GraphOps 객체로 암시적으로 제공됨)
각 연결요소는 연결요소 내 가장 작은 정점 ID로 식별함.

연결된 컴포넌트는 본래 그래프 내의 하위 그래프이며, 버텍스는 어떤 방식으로든 서로 연결됨.
즉, 동일한 컴포넌트의 모든 버텍스는 컴포넌트에서 다른 일부 버텍스의 에지를 포함하거나 에지에서 버텍스를 포함함.
버텍스를 특정 컴포넌트에 연결하는 에지가 없으면 특정 버텍스가 포함된 새 컴포넌트가 생성됨.
이는 모든 버텍스가 특정 컴포넌트에 포함될 때까지 계속됨.

그래프 객체는 연결된 컴포넌트를 계산하기 위해 connectComponents 함수를 제공함.
graph.connectedComponents.vertices.collect : 그래프에서 연결된 컴포넌트를 계산하는 코드
```



### Strongly Connected Components

```
강연결요소(SCC)는 모든 정점이 다른 모든 정점과 연결된 서브 그래프를 의미함(두 정점이 직접 연결될 필요는 없음)
SCC에 속한 모든 정점은 간선 방향을 따라 서로 도달할 수 있어야 함.
연결요소는 비방향성 그래프의 서브그래프인 반면, 강연결요소는 방향성 그래프의 서브그래프임.
즉, 강연결요소는 간선의 방향성을 고려해 정점이 연결되었는지 판단하므로
연결요소보다 더 엄격한 기준으로 그래프의 군집을 만든다고 볼 수 있음.

그래프 이론 및 기타 다양한 영역에서 SCC 응용 사례를 찾을 수 있음.
링크드인 그래프에서는 소기업, 팀, 평생 친구 사이에서 SCC를 발견할 확률이 높지만,
IT나 건설 등 산업 분야에 걸쳐 존재하는 SCC는 거의 없을 것임.

스파크 GraphOps 객체는 stronglyConnectedComponents 메서드를 Graph 객체에 암시적으로 추가함.
이 메서드에 최대 반복 횟수만 지정하면 SCC를 계산할 수 있음.
```



### 여행하는 세일즈맨 문제

```
여행하는 세일즈맨 문제는 모든 버텍스를 탐색하는 방향 없는 그래프를 통해 최단 경로를 찾으려고 시도함.
버텍스와 에지의 수가 증가함에 따라
순열의 개수는 버텍스에서 버텍스까지 사용 가능한 모든 경로를 망라하기 위해 다항식으로 증가함.
시간 복잡성은 문제를 해결하는 데 오랜 시간이 걸릴 수 있는 지점까지 기하급수적으로 증가함.
이를 완전하고 정확하게 해결하기보다는 가능한 한 최적으로 문제를 해결하기위해 greedy 알고리즘으로 알려진 접근 방식을 사용함.

여행하는 세일즈맨의 문제를 해결하기 위해 greedy 알고리즘 접근 방식은 최단 에지를 신속하게 선택하는 것임.
더 깊은 방향으로 탐색한다면 greedy 알고리즘 접근 방식이 최선이 아닌 선택일 수도 있음.
```



### ShortestPaths

```
특정 정점에서 그래프의 각 정점으로 도달하기 위해 따라가야 할 간선의 최소 개수를 찾는 알고리즘.

스파크의 최단 경로 알고리즘은 ShortestPaths 객체로 사용할 수 있음.
ShortestPaths의 유일한 메서드인 run은 그래프 객체와 랜드마크 정점 ID의 Seq 객체를 인수로 받음.
메서드가 반환하는 결과 그래프의 각 정점 속성에는 각 랜드마크로 가는 최단 경로 간선의 개수가 Map 형태로 저장됨.
이 Map의 키는 랜드마크 정점의 ID며, 값은 해당 랜드마크로 갈 수 있는 최단 경로 간선의 개수임.

최단 경로 알고리즘은 소스 버텍스에서 시작해 대상 버텍스에 도달할 때까지
버텍스를 다른 버텍스에 연결하는 에지를 탐색하는 방식으로 두 버텍스 간의 경로를 찾음.
최단 경로 알고리즘은 다양한 버텍스 사이에서 메시지를 교환해 동작함.
또한 최단 경로 알고리즘은 Graph나 GraphOps 객체의 일부가 아니라 lib.ShortestPaths 함수를 사용해 호출해야 함.

ShortestPaths는 두 버텍스 사이의 hop 개수 관점에서 최단 경로를 선택함.

에지의 가중치를 사용해 최단 경로를 계산할 수도 있음. 즉, 사용자를 연결하는 모든 에지는 동일하지 않음을 의미함.
예를 들어 에지 값, 가중치, 속성을 각 사용자의 거주지 사이 거리로 간주할 수 있다면 가중 그래프를 얻을 수 있음.
이 경우 최단 경로는 두 사용자 간의 거리로 계산됨.
```



### 페이지 랭크

```
이 알고리즘은 그래프 내 각 정점의 중요도를 해당 정점에 도착하는 간선 개수를 기반으로 계산.
주로 웹 그래프의 각 웹페이지가 가진 상대적 중요도를 분석하는 데 널리 사용됨.
알고리즘 동작 과정은 먼저 각 정점의 페이지랭크(PR)의 값을 1로 초기화하는 것부터 시작함.
그런 다음 각 정점의 PR 값을 이 정점에서 나가는 간선 개수로 나누고, 그 결과를 모든 인접 정점의 PR 값에 더함.
알고리즘은 모든 PR 값의 변동폭이 수렴 허용치 매개변수보다 작을 때까지 이 과정을 반복함.

각 페이지의 PR 값을 정점에서 나가는 간선 개수로 나누기 때문에
해당 페이지가 다른 페이지에 미치는 영향도는 이 페이지가 참조하는 링크 개수에 반비례함.
보통 페이지를 나가는 링크가 가장 적고 페이지로 들어오는 링크가 가장 많은 페이지의 PR 값이 가장 높음.

GraphX에서는 Graph의 pageRank 메서드를 호출해 페이지랭크 알고리즘을 실행할 수 있음.
메서드에는 수렴 허용치 매개변수만 전달하면 됨.
알고리즘은 PR 값에 변동이 있어도 수렴 허용치보다 낮다면 충분히 수렴했다고 간주하고 반복을 종료함.
허용치 값이 작을수록 더 정확한 결과를 얻을 수 있지만, 알고리즘이 수렴하는 데 걸리는 시간도 늘어남.
메서드는 각 정점 속성 객체에 PR값이 저장된 그래프를 반환함.

페이지랭크는 그래프 처리 공간에서 가장 중요한 알고리즘 중 하나임.
관계나 에지를 기반으로 해서 버텍스나 노드의 순위 개념을 기반으로 다양한 사용 사례 타입으로 발전함.

구글 페이지랭크는 웹 사이트가 얼마나 중요한지 대략적으로 판단하기 위해
페이지로 연결되는 링크의 개수와 품질을 계산함으로써 동작함.
기본 가정은 더 중요한 웹 사이트는 다른 웹 사이트에서 더 많은 링크를 받을 가능성이 높다는 점.

페이지랭크 알고리즘을 사용하면 기업 웹 사이트의 웹 페이지 또는 인기 있는 웹 사이트와 기술 블로그 중에서
웹 페이지를 홍보하는 블로그의 상대적 중요성을 향상시킬 수 있음.
페이지랭크 알고리즘을 사용해 사용자의 블로그 웹 사이트와 컨텐츠를 표시하는 외부 웹 사이트가 많다면
사용자의 블로그 웹 사이트는 유사한 다른 웹 페이지보다 먼저 구글 검색 결과에 나타날 수 있음.

웹 페이지를 노드나 버텍스로 간주하고 웹 페이지 간의 하이퍼링크를 에지로 생각하면 본질적으로 그래프가 생성된 것.
하이퍼링크 또는 에지의 개수만큼 웹 페이지의 순위를 얻을 수 있음. 페이지랭크는 버텍스의 중요성을 나타내는 요인이 될 수 있음.
높은 순위의 페이지랭크를 포함하는 많은 페이지에 하이퍼링크로 연결된 특정 페이지는 높은 순위를 얻음.

빅데이터 영역에서 GraphX를 사용해 페이지랭크 문제를 해결하는 방법을 살펴보자.
페이지랭크는 a-b의 에지가 a에 의해 증폭된 b의 값을 나타내는 것으로 가정하므로 그래프에서 각 버텍스의 중요성을 측정함.
예를 들어 트위터 사용자를 많은 다른 사용자가 팔로우하는 경우 해당 트위터 사용자 순위는 높음.
GraphX는 페이지랭크의 정적과 동적 구현을 pageRank 객체의 메서드로 제공함.
고정 페이지랭크는 일정한 반복 횟수 동안 실행되며, 동적 페이지랭크는 순위가 수집될 때까지 실행됨.
GraphOps를 사용해 그래프의 메서드로 패이지랭크 알고리즘을 직접 호출할 수 있음.
```



## 5. A* 검색 알고리즘 구현

```
그래프의 두 정점 사이 최단 경로를 찾는 검색 알고리즘.
이 알고리즘을 폭넓게 활용하는 이유는 최단 경로를 효율적으로 찾을 수 있기 때문임.
```



### 1) A* 알고리즘 이해

```
알고리즘은 시작 정점과 종료 정점을 받고, 이 사이의 최단 경로를 찾음.
다시 말해 각 정점별로 시작 정점과 종료 정점으로 이동하는 데 필요한 상대적인 비용을 계산한 후,
가장 낮은 비용을 기록한 정점들로 구성된 경로를 선택함.
```

![IMG_3706](https://user-images.githubusercontent.com/87686562/191516037-c395599c-be65-4fdf-a0ae-58d163470eff.jpg)

```
2차원 지도 예제로 A*알고리즘 동작 원리 이해.
지도는 사각형 격자로 구성되며, 지도상에는 시작 사각형(정점)과 종료 사각형(정점), 그리고 이들 사이의 장벽이 위치함.
각 사각형은 정점이 되고 인접한 사각형들과 간선으로 연결됨.
대각선에 위치한 사각형과는 연결되지 않으며, 오직 수평 또는 수직 방향으로만 연결됨.

옅게 색칠된 부분은 현재 정점을 의미함.
현재 정점은 알고리즘의 현재 반복 차수에서 인접 정점들의 비용을 계산하는 중심 정점을 말함.
점선은 이 현재 정점과 시작 정점 사이의 경로(즉, 지금까지 지나온 경로)를 나타냄.
이 경로 길이를 G라고 하고, 이 예제에서 두 이웃 정점 사이의 거리가 항상 1이라고 하면 G 값은 2임

파선은 비용을 계산하는 현재 정점과 종료 정점 사이의 경로를 추정한 것.
이 경로 길이는 현재 정점과 종료 정점이 얼마나 멀리 떨어져 있는지 가늠한 거리로, H로 표기.
예제에서는 H 값을 현재 정점과 종료 정점을 이은 직선 길이로 계산했지만, 그 외 다른 함수를 사용해 추정할 수도 있음.

정점의 최종 비용 F는 G와 H를 더해 계산함.	F = G + H

A*알고리즘의 핵심은 종료 정점까지 남은 거리를 추정하는 함수이므로
두 정점 사이의 거리를 예상할 수 없는 그래프에는 A* 알고리즘을 적용할 수 없음.

A*알고리즘은 미방문 정점과 기방문 정점의 그룹을 관리하면서 지금까지 지나온 현재 정점들을 기록함.
```

![IMG_3707 (1)](https://user-images.githubusercontent.com/87686562/191518259-91fe1130-0188-41d2-b782-716cbe49c604.jpg)

```
옅게 색칠된 부분은 기방문 그룹에 포함된 정점을 표현한 것임.
흰색 바탕에 숫자가 기입된 부분은 미방문 그룹의 정점임.
사각형에 기입된 숫자 중 첫 번째 줄의 숫자들은 각각 G와 H의 값이며, 두 번째 줄의 숫자는 F를 계산한 결과임.
각 반복 단계마다 현재 정점과 이웃한 각 정점의 F, G, H 값을 계산한 후 이 이웃 정점들을 미방문 그룹에 넣음.
그런 다음 미방문 그룹에서 가장 작은 F 값을 가진 정점을 다음 반복 차수의 현재 정점으로 선택하고 기방문 그룹에 넣음.
현재 정점이 종료 정점에 도달하면 알고리즘은 가장 작은 F 값을 역으로 따라가면서 시작 정점에 이르는 경로를 구성함.

알고리즘의 첫 번째 반복 단계에서는 가장 먼저 시작 정점을 현재 정점으로 설정함.
이 현재 정점의 G 값은 0이며, H 값은 계산하지 않음. 두 번째 반복 단계부터는 현재 정점을 기방문 그룹에 넣고,
현재 정점의 이웃 정점 중 기방문 그룹에 포함되지 않은 각 정점의 G, H, F 값을 계산함.
이웃 정점에 이미 값이 계산된 경우(즉, 정점이 미방문 그룹에 포함된 경우)
알고리즘은 해당 정점의 이전 값과 새로 계산한 값을 비교해 더 작은 값을 사용함.

그런 다음 미방문 그룹의 정점 중에서 가장 작은 F값을 가진 정점을 다음 반복 단계의 현재 정점으로 선택함.
선택된 정점이 목적지일 때 알고리즘은 가장 낮은 F값을 가진 정점들을 따라 되돌아가면서 최종 경로를 구성함.
```

